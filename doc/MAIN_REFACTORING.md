# Рефакторинг main.ts

## Проблема
Исходный `main.ts` содержал 600+ строк с множеством зон ответственности:
- Инициализация всех систем игры
- Обработка клавиатуры и мыши
- Управление инвентарём
- Логика экрана загрузки
- Автосохранение
- Правила дропа блоков

## Решение
Разбиение на модули по принципу единственной ответственности:

### 1. **initialization/** — Инициализация систем

#### `GameInitializer.ts` (200 LOC)
- Создание всех игровых систем (renderer, world, player, inventory и т.д.)
- Настройка связей между системами
- Возвращает объект с ссылками на все системы

**Преимущества:**
- Централизованная инициализация
- Легко добавлять новые системы
- Тестируемость (можно мокировать отдельные системы)

#### `LoadingScreen.ts` (60 LOC)
- Управление экраном загрузки
- Анимация прогресс-бара
- Отслеживание загрузки видео и ресурсов

#### `NoiseGenerator.ts` (20 LOC)
- Генерация CSS noise текстуры для иконок блоков
- Установка CSS переменной `--noise-url`

### 2. **input/** — Обработка ввода

#### `KeyboardHandler.ts` (120 LOC)
- Обработка клавиш WASD, Space, E, Escape, T, /
- Управление движением игрока
- Открытие инвентаря, паузы, консоли
- Выбор слотов хотбара (1-9)

#### `MouseHandler.ts` (80 LOC)
- Обработка кликов мыши (атака, размещение блоков)
- Прокрутка колеса мыши для хотбара
- Управление состоянием `isAttackPressed`, `isUsePressed`

#### `PointerLockHandler.ts` (60 LOC)
- События lock/unlock для pointer lock API
- Логика открытия/закрытия меню паузы
- Обработка edge cases (resume, inventory open)

### 3. **ui/** — UI контроллеры

#### `InventoryController.ts` (120 LOC)
- Открытие/закрытие инвентаря
- Переключение между обычным инвентарём, крафтом и печью
- Сохранение мира при закрытии
- Возврат предметов из крафтинг-сетки
- Мобильная адаптация (скрытие джойстика)

#### `AutoSave.ts` (40 LOC)
- Автосохранение каждые 30 секунд
- Сохранение позиции игрока, инвентаря, печей
- Методы start/stop для управления таймером

### 4. **blocks/** — Логика блоков

#### `BlockDropHandler.ts` (50 LOC)
- Правила дропа блоков при разрушении
- Проверка инструментов (кирки для камня/руды)
- Преобразование блоков (Coal Ore → Coal)

**Примеры правил:**
- Stone: дропается только с киркой
- Iron Ore: только с каменной/железной киркой
- Coal Ore: дропает Coal (не руду)
- Furnace: требует кирку

### 5. **main.ts** — Точка входа (100 LOC)

Теперь содержит только:
1. Инициализацию текстур и noise
2. Создание систем через `GameInitializer`
3. Создание `Game` instance
4. Подключение input handlers
5. Настройку callbacks
6. Запуск загрузки мира
7. Старт loading screen

## Архитектурные улучшения

### Разделение ответственности
- **Инициализация:** `GameInitializer`
- **Ввод:** `KeyboardHandler`, `MouseHandler`, `PointerLockHandler`
- **UI логика:** `InventoryController`, `AutoSave`
- **Игровая логика:** `BlockDropHandler`

### Dependency Injection
Все зависимости передаются через конструкторы:
```typescript
new KeyboardHandler(
  gameState,
  player,
  inventory,
  inventoryUI,
  cli,
  onToggleInventory,
  onShowPauseMenu,
  onHotbarChange,
)
```

### Callbacks вместо прямых ссылок
```typescript
// Вместо прямого вызова inventoryController.toggle()
onToggleInventory: (useCraftingTable: boolean) => void
```

### Тестируемость
Каждый модуль можно тестировать изолированно:
- `BlockDropHandler.getDropInfo()` — чистая функция
- `LoadingScreen` — можно мокировать DOM элементы
- `KeyboardHandler` — можно эмулировать события

## Метрики

### До рефакторинга
- `main.ts`: 600+ LOC
- Зоны ответственности: 8+
- Сложность: высокая (всё в одном файле)

### После рефакторинга
- `main.ts`: 100 LOC (↓83%)
- Модулей: 10
- Средний размер модуля: 60-120 LOC
- Максимальный размер: 200 LOC (`GameInitializer`)

## Преимущества

### Читаемость
- Легко найти код по функциональности
- Понятная структура папок (`input/`, `initialization/`, `ui/`)

### Поддерживаемость
- Изменения в одной области не затрагивают другие
- Легко добавлять новые input handlers или UI контроллеры

### Переиспользование
- `BlockDropHandler` можно использовать в других местах
- `LoadingScreen` можно адаптировать для других экранов

### Тестирование
- Каждый модуль можно покрыть unit-тестами
- Легко мокировать зависимости

## Дальнейшие улучшения

### Возможные оптимизации
1. **Event Bus:** Заменить callbacks на event-driven архитектуру
2. **Config Objects:** Группировать параметры конструкторов в объекты
3. **Factory Pattern:** Для создания input handlers
4. **State Machine:** Для управления состояниями UI (menu, inventory, game)

### Потенциальные проблемы
- **Coupling:** `GameInitializer` знает обо всех системах (facade pattern)
- **Callbacks:** Много callback-параметров в конструкторах
- **Private field access:** `systems.inventoryUI["dragDrop"]` — хак для доступа

### Решения
```typescript
// Event Bus вместо callbacks
eventBus.on('inventory:toggle', (useCraftingTable) => {...});

// Config Objects
new KeyboardHandler({
  gameState,
  player,
  inventory,
  callbacks: {
    onToggleInventory,
    onShowPauseMenu,
    onHotbarChange,
  }
});
```

## Миграция

### Обратная совместимость
- Все функции работают идентично старой версии
- API `Game` класса не изменился
- Сохранения совместимы

### Тестирование
1. Запуск игры: ✅
2. Движение (WASD): ✅
3. Инвентарь (E): ✅
4. Крафтинг: ✅
5. Печь: ✅
6. Автосохранение: ✅
7. Мобильные контролы: ✅

## Заключение

Рефакторинг `main.ts` улучшил:
- **Читаемость:** код разбит на логические модули
- **Поддерживаемость:** легко найти и изменить функциональность
- **Тестируемость:** каждый модуль можно тестировать отдельно
- **Масштабируемость:** легко добавлять новые системы

Размер `main.ts` сократился с 600+ до 100 строк (↓83%), при этом функциональность осталась полностью идентичной.
